# Holon

## *Ch 0: Introduction*

Holon is defined by Wikipedia as a [system](https://en.wikipedia.org/wiki/System) (or [phenomenon](https://en.wikipedia.org/wiki/Phenomenon)) that is an [evolving](https://en.wikipedia.org/wiki/Evolution) [self-organizing](https://en.wikipedia.org/wiki/Autopoesis) [dissipative](https://en.wikipedia.org/wiki/Dissipative_structure)\[[*citation needed*](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)\] [structure](https://en.wikipedia.org/wiki/Structure), composed of other holons, whose structures exist at a balance point between [chaos](https://en.wiktionary.org/wiki/chaos) and order. A holon isn't actually "real" in the sense that matter is real. A holon is an abstraction. In programming terms, a Holon is the interface and not the implementation. Machine code is the only form of information that runs on real processors and likewise, matter as bounded packets of energy is the only thing that runs around in the universe and every conceptualization above the quanta is macroscopic "high level code" that predicts how the low level stuff will behave. When the college hippies say "Everything is one man. We are all just endless energy", there is some truth to that. However, when discussing with hippies, it is best to stay away from the concrete details of reality, lest you decide to throw a physics book at them out of anger and of an attempt to break them from their trance like oneness. What the hippies do get that more straitlaced peers overlook is that reality arrives at our perceptions in "packets of understandability". I don't converse with neurons, I converse with humans. China doesn't deal with US citizens in general, but it sure deals with the United States. Each fractal level of reality can be defined by an interface and even though the implementation of that interface consists of layers and layers and layers of abstraction on top of atoms, reality has found it "best" to encapsulate these layers in the same way a programmer encapsulates their data into an object. These objects of reality are what I call "Holons"

The intent of this book is to define the various Holons found in our reality. As I describe the various holons and their interactions in this book, I will link to classes of my Holon codebase that formally defines the concepts involved. The end result is a coded implementation of my own mental model alongside my description of that model which will be found in this book. I do not intend to make this book too code intensive, but I will insert small snippets of formatted code into the text of this book as I see fit. The goal of the book itself is to describe my formal mental model of reality to any technically minded reader, regardless of their programming experience.  For the more experienced programmers reading this book, I hope you find my codebase to be useful. The code is heavily tailored to my own mental model and may not be suited to your needs, but over the course of this book I think both hacker and pleb alike will find just how important it is to formally define even the most mundane of concepts in computer code. There were many bugs lurking in my intuitive/unformal understanding of reality that revealed themselves and were patched once they were formally defined in code. If you, the reader, push through this book despite its density, verbosity, and eccentricity: in the end I think you will see the power of the Holon.

## *Digital Reasoning*

Biases are generally easy to percieve in others but difficult to percieve in oneself. Biases can stack on top of eachother to form idologies that are then transfered memetically to various minds. The minds that are most habitable to various ideologies probably had several of the underlying biases contained in the ideology, but probably in less evolved forms. I could fill this section with example of these ideologies, but it will only serve to anger readers. Just think your most hated ideological group of people and then imagine what kind of mental biases they must have in order to believe the things that they do. Really try to put yourself into the mindset of a person in this vile group, whatever that group is? What life experiences must these people have had. What life experiences haven't they had. If you were in their shoes, but retained an angel of your rational self on your shoulder attempting to convince you that this vile ideology is wrong, what would that angel say?

The truth is that you yourself may have underlying biases which allow various ideological memes to reside in your mind. There may be people out there who will attempt to vilify you because of these ideas. When people decide to vilify others, they fail to empathize with the truths that can be found in another person's mindset regardless of how large or small those truths may be.

One of the goals of this project is to build "digital reasoning machines" to structure one's mental model of the world such that the biases that seem to cloud the rationality of much of the world around us does not affect your judgement more than it has to. Completely eliminating bias is impossible (everyone and everything has a perspective). However, what machines lack in intuition they gain in objectivity. A computer only does what it is programmed to do. The rigidity of the machine may help to root out biases and untruths from ones mental model.

Let me give an example in my daily life: presume that I make a resolution to spend enough time reading each day. If I am particularly uncommitted to this idea, I won't even specify how much "enough time is". If I am at least a bit serious about this goal, I will define it quantitatively by stating "I will read 40 minutes each day from a software development book". Now I have formal fitness function that I as a human can understand, but I won't know exactly how to evaluate my performance. I may get a 10 minute phone call in the middle of my reading session and forget to keep track of the time so I just count it towards my reading for that day. Even worse still is that in order to stay committed to my resolution, I have to track how good I am doing so I can plan about how to stay commited when inevitable interferences come up. Say my work hours change and that time block from 6am to 7am I normally spend reading now needs to be spent driving so I can get to the office by 7. It may be too easy to just forget about doing the reading. If I have a digital tracker in place to alert me, this won't be a problem.

## The History of Holon
My introduction with "holon" began during a psycadelic experience. I was about to leave the United States for an undetermined period of time and my friend decided I should have an LSA fuelled going away party. LSA is a naturally occuring cousin of LSD and has similar but less pronounced effects. Some how, during my trip I stumbled upon a chart documenting the 4 functions of a holon: transcendence, communinion, individuation, and desolution. It was derived from Ken Wilber's philosophy on the matter. At the time, the chart made a really huge impact, but I put it away in the back of my mind until a year later

I 2017, I became obsessed with holons. I was a month into living in New York city and it was my first time living in a metropolis that housed over a million people. I am absolutely facinated by cities. Back in highschool, my biology teacher used cities as a metaphore for cells. Ribosomes are the factories, The nucleus is town hall. Lysosomes are the trashmen. Transport protiens are the ports. So on and so forth. So moving to New York city got my mind racing about "fractalized being" and eventually my mind snatched ahold of the concept of Holons and never let go. It is impossible to operate in a city as complex as New York without a supurb ability to think in terms of holonic levels. One consequence of holonic complexity is the abundance of emergent properties and the major consequence of emergence is statistical power laws. New York may have 10x the population of medium cities but it has 1000x the # of billionaires and same with homeless people. When complex factors compound, they create exponentials expressed in salient metrics. There is an entire book called "Scale: The Universal Laws of Growth, Innovation, Sustainability, and the Pace of Life in Organisms, Cities, Economies, and Companies" by Geoffrey West that covers this topic. Armed with my new vocabulary word "holon" and an obsession with the Scale book, my subconcious began to formulate the goals of this project.

## Sources of inspiration

In this section, I want to identify several of the sources of inspiration I have had for the Holon project. This project did not originate as a startup idea or as a mandate from a book. Rather it began its life as a destraction. In 2014, I started working on building a robotics company, but I constanly was distracted with the meta process of improving my performance in building and designing robots. By 2016, I started working full time on a self improvement AI with the justification that I would put it inside of a robot when I was finished. I desperately tried to commenserate what my stated goals where with what I was actually working on. Slowly, I began to realize that personifying the system I was building was a detriment to using the system. It took ~4 years to finally realize that what I cared most about was a cybernetic mind extension. It took me 4 years to figure out what I was really even working on. It took an extra year and a half to feel confident in pursuing this line of work in earnest. It has seemingly no way to monitize it, because in effect, I am suggesting that everyone build their own version of Holon using my version as just 1 implementation of the idea. Despite this, I have been given an indication that my pursuit is worthwhile by the book Principles by Ray Dalio. In the book he discusses how humans will systemize their thought processes in expert systems that can be compiled and executed on digital CPUs. In the book, Mr Dalio said that this evolution of human thought is of the upmost importance. I agree with him. My goal is not to build a thinking machine, but rather to build a system that is tightly coupled to myself. I see this as a massive self improvement project. How can one make money from that when "self-help" seems to be the industry of hucksters?

## Software is fragmented

In Eric Raymond's book, The Cathedral and the Bazzar, Eric makes the assertion that a Bazzar has a more lively atmosphere due to its emergent properties. Cathedrals run on schedules and ritual while Bazzars run on unpredictable marketplace interactions. The Bazzar approach to software development inside the Free and Open Source Software movement has led to a large number of collaborators in software systems. This gave FOSS an advantage over corporate competitors by supplying more man-hours/$ than any proprietary project could have achieved. What it gained manpower, it lost in consistency and direction. A GNU/Linux system has many redundant libraries, each with their own interface variances. FOSS systems not only have to compete with proprietary projects, but also with other FOSS projects and because a FOSS project is not normally driven by profit motive, the number of FOSS competitors generally outnumbers proprietary competitors. This has led to a fracturing of software systems and not just across language lines (although, language choice is one of the larger chasms to cross in software development). Each system has their own way of handling input, errors, output, etc. GUI systems including Java's Swing, GNU's GTK, TCL's Tk, CommonLisp's McCLIIM, and QTCOM's Qt, just to name a few, all function under their own unique paradigm and I haven't even talked about the poliferation of web technologies we see today. To be a "full stack developer" across the entirety of one's computing system (not just web), seems infeasable due to the numerous technologies that someone would have to learn to operating on all layers of their system. The bazzar approach to development has created layers and layers of inoperable technical sediment that no one person has the ability to navigate with skill. Does it have to be this way in FOSS?

## Each Class gets a main

One cool thing about java is that each class can stand as its own independent program by providing a main function. I can compile all of the classes, each of which has their own main function, and this is perfectly acceptable. In C/C++ only one main function can be defined in the entire program.

With each class getting its own main function, I do not have to write what I call application classes. Instead each class independently acts as its own application class.

## *The tech stack*

A major focus of software engineering has been on tool development. For this reason, a component of Holon is the tech stack. Software developers have editors, command lines, IDEs, debuggers, scripts, project management tools, source control, and much more. Each class of tech has many different species to choose from. I personally wanted to have written most of the tech stack that I directly interact with.

The tech stack gets its own class and holds a list of many system components at various levels in the stack. Software, hardware, daemons, and documentation are all listed in the stack.

### The filesystem
The filesystem I propose is not unique in the realm of computer science, but it is very unique to the realm of consumer operating systems. Holon will use a database filesystem. Unix's "everything is a file" mantra was invented before the rise of the RMDB through Oracles popularization of SQL. This means that the filesystem of modern day operating systems is using old technology. With SQL, data can now be stored and retrieved by type and access can be restricted by application, user, or any other type of restriction required. Because Holon will use a single JVM to run all the applications, code can be pulled from the database using a custom classloader and loaded directly into the JVM.The modularity of the JVM allows such code schemes to be mplemented.

While, I originally conjured up this idea from my immagination, the sometimes true aforism "nothing new under the sun" rings true in this particular case. After reading the current Wikipedia article on filesystems, it I discoverd that the idea of a database file-system is as old as the RMDB itself. Oracle has implemented a DBFS, which gives me a working example to study and tweak.

Java files could be stored in a JavaSource table. MetaData about the class could also be generated and used to do static analysis of the code. ByteCode could be stored in another table and the same principle about meta data could apply. Images could be stored in a structured format as well, with metadata being encoded right into the table itself. This would drastically speed up decoding the image from harddisk. There are so many image file formats that could be unified if a database table were used to store images instead of a binary file. I am sure databases already store data in as compressible a format as possible. The database layer would always be able to transform that raw data into text on demand, so the principle of "use plain text files" would not be violated, ever!

What strikes me as most intersting about this concept is that I could store data in the exact same format that I would use the data as a class in the Java system. Implementing a Object filestore inside of a database could be my SOLE filesystem. Why would I ever need anything else? Source code would be saved into a table as a TextBuffer and metaData concerning the source could could also have its own table.

I REALLY hate `cd`ing through my hard drive to find files. Having a simple API that goes something like `mp3.byArtist("Tool").byBPM(100, 130)` would be so fucking dope! No more would I have to drag files from my ~/Downloads folder into the correct folder. If it has .mp3, it goes into the music table, .jpg, it goes into the imgs table, etc, etc.

For the past few years, I have been dreaming about a software system with seamless datastore. Using files to serialize datastructures that can be read by a variety of programs written by a variety of people makes sense in Eric Raymond's bazzar world, but it does not make sense in a holistic world of a single personal computing system. A unified and structured file system makes more sense to me than the current model. For this reason, Holon will use a DBFS.

A significant problem I see with this model is that source control such as git requires source to be organized in a standard file system. This means I would have to make my source code take on the presentation of a standard filesystem while it is actually stored as a DBFS. While this is a problem it is not as significant a problem as I imagined compilation from a DBFS would be. Despite my fears, the javax.tools package of the Java ecosystem seems to have EVERYTHING I need to operating on java code from java code. The `javac` program will never have to be ran in my system. I can load code directly from the DBFS and programatically compile it.

#### Exploration of DBFS stacks

I spent some time researching the various stacks I could use for a DBFS. I want a method that seamlessly persists Plain Java Objects. I wasted several hours of time by attempting to try out the first stack I found before researching the others. This stack was JDO + DataNucleus + Neo4j. I couldn't get it to work. DataNucleus' implementation of the JDO protocol was broken. I then tried to use DataNucleus with Postgres and that was broken too. I then realized my mistake of prematurely hopping into an implementation and I decided to spend a singnificant amount of time researching the other options. At first, I thought a JDO implemetation was still the way to go, because the marketing material on Appache's JDO site said that it handled POJOs better than Java's JPA. After looking through the list of JDO implementations on Appache's site, I realized that JDO is an outdated protocol and that despite the marketing, JPA should be used. The one JDO implementation that gave promise used a custom database to store Java Objects and that database cost money if I wanted to store more than 10 types of objects (which I did). So I decided to look into JPA, which is the Official Java Persistence API. The most well known implementation of the JPA is Hibernate. Learning from my previous time waste, I went onto YouTube and watched a video about POJO persistence using RDBMS. Hibernate and several Spring Data solutions were discussed.

I decided that Hibernate would be the best option, because it is the most popular implementation of JPA and that usually means many bugs have been fixed by open source developers. Also, the DataNucleus JDO implementation required enhancement of Bytecode after compilation. Basically, the classes needed to be wrapped by a proxy. Hibernate seemed to not have this requirement. Hibernate also gets rid of the JavaBean requirement for entities which is something that the standard Java Persistence API absolutely requires; I hate JavaBeans because it isn't very Object Oriented, so Hibernate's elimiation of the JavaBean requirement was great for me. After looking at the documentation for Hibernate's ORM, I decided that I did not like the details I had to annotate with to describe Entity associations. I do not want to think about Joins when using my object store. I want all of that taken care of for me. I then looked at Hibernate's NoSQL implementations of the JPA and really liked the simplicity of the MongoDB implementation. It seemed that all the Association details were taken care of by the library it self. I did not have to use complex annotations when describing Associations. The only problem I had with MongoDB is that the max document size is 16Mb. This means that I can not store images or video inside of MongoDB itself. What Holon does is keep most of its data in MongoDB and when data for an object exceeds 16Mb in the case of Photos or Videos, I place the binary data portion of the Object inside a binary file sitting in a single directory. The binary file is named with a UUID and the only way to make sense of it is to load the associated metadata from MongoDB. When I want to retrieve a Picture in Holon, I make a request to MongoDB, it sends me a bunch of metadata back and then I use the metadata to locate the image data. The image file doesn't neccisarily have to follow any particular image format. All of the image headers can be stored as metadata and the pixels themselves could be the only thing saved to the file. This means that the files may be useless to any application that knows how to read JPGs or PNGs. The header data will be missing, so these applications will not be able to use the files. Why would I want this? I would want this because I want to completely depreicate the antiquated Linux File System and replace it completely with a DBFS. If binary data files that act as workarounds for the 16Mb limit can be read by any 'ol application, then the DBFS could be bypassed completely. I don't want this. I want that implementation detail to be encapsulated.

The one problem with implementing my POJOs without Setters and Getters is that Holon is now tied in to using Hibernate, since it is the only JPA implementation I know of that does not follow the protocol and require the POJOs to be JavaBeans.

#### javax.tools.JavaFileManager for DBFS

Because I will be using a DBFS, I will need to implement a DBFS version of the `javax.tools.JavaFileManager` class such that all of the classes in `javax.tools` will have access to my database filesystem. There are 12 methods to implement for the JavaFileManager, so it won't be a simple task, but it will be doable. Likewise, a JavaFileManager.Location will also have to be implemented. After implementing these 2 interfaces, I should be able to use all of the Java diagnostic and compilation tools required for a programming workflow that only uses the DBFS system.

#### DBFS as a strong motivator to finish Holon

One advantage that the DBFS provides me as I implement Holon is that it is massively rewarding to be implementing such an innovative filesystem for a personal operating system. Not a single personal computer that I know of uses a DBFS as their primary file system. For me, finishing a system is a challenge. I get bored of the system and decide it isn't worth the effort. The DBFS is incredibly exciting to me and will be a major driving force behind why I will be able to complete the Holon personal computer for myself.


#### DBFS lowers the impedence between code and datastore.

Traditionally, there has been a high impedence between a datastore format and the code that uses the data. With a DBFS, the datastore will look more like the Object that uses the data. There no reason why Objects themselves should not be stored on the hardrive by default. The Holon system will do this.

### The shell

The number of configurations a shell program can run are vastly greater than what an equivalent GUI program can run. The power of the shell simply can't be overlooked. However, most Unix distributions come with Bash as their shell and few people decide to replace it. Shell is equivalent to Bash, but that doesn't have to be the case. I built my own shell in Java. It allows me to launch sandboxed Java programs in the same JVM that the shell is running in. This means that Java threads become much like Linux processes in that the Java thread is how program seperation occurs. Memory between both programs are obviously shared, but this is not a problem due to high level memory management. In a c++ program, it would be easy for one thread to clobber the memory of another thread, but in Java the only way that can happen is if one thread has reference to an object that another thread is using. If I sufficiently seperate the programs that are running in my JVM using a custom class loader, it will become virtually impossible for one program to clobber the other program. The reason for this is that any object created with my custom class loader can not be used by an object created by a seperate instance of my custom class loader. If an object's defining classloader is not in the Classloader hierarchy of another object, then the 2 objects can never interact with eachother. Usually classloaders form a single linked list, which ensures that all objects have their defining class loader in the heirarchy of all other objects. However, my custom classloader branches that linked list into a tree which means that some objects are completely seperated from other objects in the classloader hierarchy. The only way these 2 objects can communicate with eachother is by passing around objects whose classes were defined in classloaders that are higher than the branch point seperating the 2 objects in the classloader heirarchy. Things in the Java language spec such as String, Object, Integer, etc can all be shared amongst these seperate processes, but the process that instanciated the custom class loaders would have to be responsible for using reflection to pass common objects around. One object can not simply hold reference to another object defined in seperate branches of the classloader heirarchy.

What I can do is create a pseudo-pipe structure that routes objects that are defined by a common classloader between to objects sperated by their branching class loaders. I could define a Pipe object in a common class loader, instanciate it, and then pass it to the various objects defined by the branching class loaders. Then the 2 objects could communicate via predefined pipe API. Any object defined by a common Classloader could be passed through the pipe if neccisary. In linux, usually the only things passes through pipes are primatives, because primatives are the least common denominator of processes whos internal structure is written in C code. However, in my scheme, any object that has been defined by a common classloader in Java is fair game. Even complex user made structures can be piped directly as long as the class of the object being piped shares the same classloader relative to the objects doing the piping.


### The editor

The editor I built is a hybrid of Emacs and Vim. I want an editor that is extensible in a language I like writing in and neither Vim or Emacs meets that requirement. That alone would be enough reason for me to want to write myown editor, but there are still more reasons to do so. By writing the editor, I will understand how its interneals work which will greatly enhace my ability to write extensions for it.

#### Seperation of concerns

The editor will use an MVC pattern. I wish to seprate the logic from the view, because I probably run this on android, java's swing, in a simple terminal, and on a web page. Android uses an XML view, Swing uses a components view, the terminal view will be written in curses, and the web view will use java compiled to ASM that prints to the web page. The underlying data structures that drive the editor will be the same regardless of display platform.



#### Components

The main class inside the editor is the Buffer. The Buffer class is what logically manages the text that is being written. It is the only object that gets fed to the Editor window's display method. The buffer has a name and is associate witha particular file that it can read from and write to.

### Perception

Cybernetics systems almost always have inputs that drive the feedback loops. Holon has several main inputs: Internal system state, Keyboard input, Internet API calls, Vision.

#### Internal System State

Holon will constantly be monitoring itself. It will look at how many processes are running, what code is being executed, and what results are being produced. Much of this data will be recorded in log files that Holon will then analyze. Holon will have a fitness function related to its internal system state and it will use the log files + the fitness function to back propogate error into the system and learn what motifications should be made to make the system more fit. Likewise, it will produce human readable reports so I can manually tweak code to perform better relative to the fitness function.

#### Keyboard input

Keyboard input is the primary way that I currently communicate with digital cybernetics systems. The output of my 10 fingers has less social side effects than talking to my system. It also allows me to input througha large domain very precise information that speaking just can not do efficiently. Imagine trying to write code using your voice. "Open paren" for instance has 3 syllables that must be pronounced, where as I can simply hold shift and press the ( key to generate that symbol on my keyboard. Holon will need to know how to interpret keys in every situation. Emacs handles this requirement by allowing users to define "modes", both major and minor. A mode defines how a program will respond to a key and a mode exists independently from a particular program running that mode.

#### Vision

This mode of perception is the one that humans are most familiar with and the one tha computers have the most trouble with. Only in the last decade have computer scientists began to tackle vision in a significant way. ImageNet competitions have been the driving force behind the advancements in computer vision technology. Now with a simple GPU it easy to implement object recognition on a home computer. Holon will have a lot of computer vision incorporated into the system, initially just to observe me as the user. Over time, I will instanciate components of Holon into robots IRL that will then collect data about their environments. I envision a robotic pet that follows me around, constantly collecting data about my life experience

The vision system is written in pure Java. I did not want to deal with native OpenCV. It is a pain to install, it does not work with Maven, and it realies heavily on finalizers to clean up native Matrix structs. If images are being processed at 20fps, the GC can not keep up with finalizing all of the frame and the computer system runs out of memory completely. This is a well documented bug in OpenCV for Java.

Instead of OpenCV, I holon uses BoofCV + a small webcam capture library. The Eye class wraps the webcam capture.

## Daemons

Each daemon process runs in a Java thread on a single JVM instance. The most computationally intensive daemon process is the vision process. It is constantly recording and analyzing visual data in Holon's environment. The environment is defined by the PhysicalSpace in which all hardware controlled by Holon is located in. For instance, if I have a server at home running Holon and an instance inside my smart glasses that is feeding visual data to the server at home via a 4G connection, then the Holon environment consistes of the space around my person and the space the server occupies (which the server may be sensing via security cameras and the like).

## Holon environment

A holon environment is defined by all the Holon instances that a single user has direct control over. Any machine in the Holon environment can interact with any other machine via the public methods in the Holon classes. Because of liberal security policy, it is important that Holon detects comprimises early and often in order to boot comprimised instances from the Holon environment.

## Code Editing Tools

Holon is built for hackers. Its goal is to enable human evolution through technology. As such, one of its major components is a code manipulation suite. Among other things, Holon aspires to be as powerful for computer programmers as an IDE like Eclipse or Visual Studio. Unlike these IDEs, Holon will include many other tools of information processing. The knowlege required for optimal programming does not exist in from knowledge in other seemingly inconsequential subjects. All subjects inform eachother. As such, classes for every physical and abstract model I can think of will be at my fingertips when programming.


### If Holon works like I expect it to, then it won't become my primary income source.

If Holon is truely successful at improving my cognitive performance, then I shouldn't have to make the majority of my money on it. With improved cognitive performance, I will be able to make my money elsewhere. It is only then that I will truly stress-test Holon. The reason I am willing to read Ray Dalio's self-help book and not the "Here in My Garage" guy's book, is that Ray has already stress tested his ideas. He is not making the majority of his money on selling his book. Rather, he earned his money from making intelligent principled decisions in hedge fund investments. If my hypothesis about Holon is correct, it will lead to many projects and companies that will make money for me. It isn't that I don't plan to monitize Holon, but it is more that I don't want Holon to make up a large percentage of my income

## The Window Manager

As part of Holon, I want to include a window manager. The best window managemetn system I have ever used was not a window management system at all, it was Emacs. I like Emacs style window management, because hotkey customization uses the sameframework for spawning and moving around windows as emacs uses for everything else. This means I only have to learn 1 hotkey system and I can even put keybindings for all of my applications into a single file. In contrast to this, vim uses a different keybinding language than dwm which is different than i3. I wouldn't even know how to keybind to functions in other software like my pdf viewer for instance. The lack of consistency for keybinding across my entire computing system means that I probably won't do any key binding at all for most applications. This does not make for a good user experience. The window manager is one of the most basic peices of software a computer has. The window manager of a power user (ie software craftsman) is almost always heavily keybound for fast movement and switching. For this primary reason, I am going to make my own window manager for Holon. It will start out as a simple tiling window manager like DWM and it may grow in complexity as time goes on. These days, I do pretty much everything I need to inside of i3, so I see no reason to get any fancier than i3 until I start using and augmented reality window manager for hardware like the Microsoft HoloLens. Of course, I will need to wait until a free (as in freedom) augmented reality system has been built in hardware. No way am I going to run Microsoft's code on an always running cammera attached to my skull.

## Tracking

Long before deciding to make Holon, I had a system that would track vital metrics and produce reports for me. This allows me to verify that I am hitting targets and to make adjustments if neccisary. It is obvious to me that data tracking will be a huge component of Holon. Not only will it be useful generating reports about my own behaviour, but it also will populate the various Objects that model Holon's reality with data in its enivronment. I have a large list of data that should be tracked and that list grows each and every day. Most of that list relates only to my own actions, so it is sure to MASSIVELY increase in size once it starts tracking data generate by the outside world. My system could track economic trends and markets. It could track elections and political offices. It could track city population sizes and other metrics related to a city's wellbeing. Generating models of the world around me is the primary reason for Holon's existence and data tracking is how Holon gets data to populate those models.
